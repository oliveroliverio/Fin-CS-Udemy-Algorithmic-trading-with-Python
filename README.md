# [Main](https://www.udemy.com/course/algorithmic-trading-with-python-and-machine-learning/learn/lecture/21523806#overview)


## 1. What is Algorithmic Trading / Course Overview

## 2. How to get the best out of this course

## 3. Did you know...? (what Data can tell us about Day Trading)

## 4. Student FAQ

## 5. *** LEGAL DISCLAIMER (MUST READ!) ***

## 6. Our very first Trade

## 7. Long Term Investing vs. (Algorithmic) Day Trading

## 8. Overview & the Brokers OANDA and FXCM

## 9. OANDA at a first glance

## 10. How to create an Account

## 11. FOREX / Currency Exchange Rates explained

## 12. Our second Trade - EUR/USD FOREX Trading

## 13. How to calculate Profit & Loss of a Trade

## 14. Trading Costs and Performance Attribution

## 15. Margin and Leverage

## 16. Margin Closeout and more

## 17. Introduction to Charting

## 18. Our third Trade A-Z - Going Short EUR/USD

## 19. Netting vs. Hedging

## 20. Market, Limit and Stop Orders

## 21. Take-Profit and Stop-Loss Orders

## 22. A more general Example

## 23. Trading Challenge

## 24. FXCM at a first glance

## 25. How to create an Account

## 26. Example Trade: Buying EUR/USD

## 27. Trade Analysis

## 28. Charting

## 29. Closing Positions vs. Hedging Positions

## 30. Order Types at a glance

## 31. Trading Challenge

## 32. Introduction

## 33. Download and Install Anaconda

## 34. How to open Jupyter Notebooks

## 35. How to work with Jupyter Notebooks

## 36. Tips for Python Beginners

## 57. Conclusion and Outlook

## 58. Introduction and Downloads Part 2

## 59. Importing Time Series Data from csv-files

## 60. Converting strings to datetime objects with pd.to_datetime()

## 61. Indexing and Slicing Time Series

## 62. Downsampling Time Series with resample()

## 63. Coding Exercise 1

## 64. Getting Ready (Installing required library)

## 65. Importing Stock Price Data from Yahoo Finance

## 66. Initial Inspection and Visualization

## 67. Normalizing Time Series to a Base Value (100)

## 68. The shift() method

## 69. The methods diff() and pct_change()

## 70. Measuring Stock Performance with MEAN Returns and STD of Returns

## 71. Financial Time Series - Return and Risk

## 72. Financial Time Series - Covariance and Correlation

## 73. Coding Exercise 2

## 74. Simple Returns vs. Log Returns

## 75. Importing Financial Data from Excel

## 76. Simple Moving Averages (SMA) with rolling()

## 77. Momentum Trading Strategies with SMAs

## 78. Exponentially-weighted Moving Averages (EWMA)

## 79. Merging / Aligning Financial Time Series (hands-on)

## 80. Helpful DatetimeIndex Attributes and Methods

## 81. Filling NA Values with bfill, ffill and interpolation

## 82. Timezones and Converting (Part 1)

## 83. Timezones and Converting (Part 2)

## 84. Introduction to OOP and examples for Classes

## 85. The Financial Analysis Class live in action (Part 1)

## 86. The Financial Analysis Class live in action (Part 2)

## 87. The special method __init__()

## 88. The method get_data()

## 89. The method log_returns()

## 90. String representation and the special method __repr__()

## 91. The methods plot_prices() and plot_returns()

## 92. Encapsulation and protected Attributes

## 93. The method set_ticker()

## 94. Adding more methods and performance metrics

## 95. Inheritance

## 96. Inheritance and the super() Function

## 97. Adding meaningful Docstrings

## 98. Creating and Importing Python Modules (.py)

## 99. Coding Exercise 3: Create your own Class

## 100. Introduction to Part 3

## 101. Trading Strategies - an Overview

## 102. Downloads for Part 3

## 103. Getting the Data

## 104. A simple Buy and Hold "Strategy"

## 105. Performance Metrics

## 106. SMA Crossover Strategies - Overview

## 107. Defining an SMA Crossover Strategy

## 108. Vectorized Strategy Backtesting

## 109. Finding the optimal SMA Strategy

## 110. Generalization with OOP: An SMA Backtesting Class in action

## 111. Creating the Class (Part 1)

## 112. Creating the Class (Part 2)

## 113. Creating the Class (Part 3)

## 114. Creating the Class (Part 4)

## 115. Creating the Class (Part 5)

## 116. Creating the Class (Part 6)

## 117. Creating the Class (Part 7)

## 118. Creating the Class (Part 8)

## 119. Simple Contrarian/Momentum Strategies - Overview

## 120. Getting the Data

## 121. Excursus: Your FAQs answered

## 122. Defining a simple Contrarian Strategy

## 123. Vectorized Strategy Backtesting

## 124. Changing the Window Parameter

## 125. Trades and Trading Costs (Part 1)

## 126. Trades and Trading Costs (Part 2)

## 127. Generalization with OOP: A Contrarian Backtesting Class in action

## 128. OOP Challenge: Create the Contrarian Backtesting Class (incl. Solution)

## 129. Mean-Reversion Strategies - Overview

## 130. Getting the Data

## 131. Defining a Bollinger Bands Mean-Reversion Strategy (Part 1)

## 132. Defining a Bollinger Bands Mean-Reversion Strategy (Part 2)

## 133. Vectorized Strategy Backtesting

## 134. Generalization with OOP: A Bollinger Bands Backtesting Class in action

## 135. OOP Challenge: Create the Bollinger Bands Backtesting Class (incl. Solution)

## 136. Machine Learning - an Overview

## 137. Linear Regression with scikit-learn - a simple Introduction

## 138. Making Predictions with Linear Regression

## 139. Overfitting

## 140. Underfitting

## 141. Getting the Data

## 142. A simple Linear Model to predict Financial Returns (Part 1)

## 143. A simple Linear Model to predict Financial Returns (Part 2)

## 144. A Multiple Regression Model to predict Financial Returns

## 145. In-Sample Backtesting and the Look-ahead-bias

## 146. Out-Sample Forward Testing

## 147. Logistic Regression with scikit-learn - a simple Introduction (Part 1)

## 148. Logistic Regression with scikit-learn - a simple Introduction (Part 2)

## 149. Getting and Preparing the Data

## 150. Predicting Market Direction with Logistic Regression

## 151. In-Sample Backtesting and the Look-ahead-bias

## 152. Out-Sample Forward Testing

## 153. Generalization with OOP: A Classification Backtesting Class in action

## 154. The Classification Backtesting Class explained (Part 1)

## 155. The Classification Backtesting Class explained (Part 2)

## 156. Introduction to Iterative Backtesting ("event-driven")

## 157. A first Intuition on Iterative Backtesting (Part 1)

## 158. A first Intuition on Iterative Backtesting (Part 2)

## 159. Creating an Iterative Base Class (Part 1)

## 160. Creating an Iterative Base Class (Part 2)

## 161. Creating an Iterative Base Class (Part 3)

## 162. Creating an Iterative Base Class (Part 4)

## 163. Creating an Iterative Base Class (Part 5)

## 164. Creating an Iterative Base Class (Part 6)

## 165. Creating an Iterative Base Class (Part 7)

## 166. Creating an Iterative Base Class (Part 8)

## 167. Adding the Iterative Backtest Child Class for SMA (Part 1)

## 168. Adding the Iterative Backtest Child Class for SMA (Part 2)

## 169. Using Modules and adding Docstrings

## 170. OOP Challenge: Add Contrarian and Bollinger Strategies

## 171. Introduction and Overview

## 172. UPDATED: Downloads for Part 4

## 173. Updating the Wrapper Package (Part 1)

## 174. Updating the Wrapper Package (Part 2)

## 175. **Weekend and Bank Holiday Alert**

## 176. Historical Data, real-time Data and Orders (Recap)

## 177. Preview: A Trader Class live in action

## 178. How to collect and store real-time tick data

## 179. Storing and resampling real-time tick data (Part 1)

## 180. Storing and resampling real-time tick data (Part 2)

## 181. Storing and resampling real-time tick data (Part 3)

## 182. Storing and resampling real-time tick data (Part 4)

## 183. Storing and resampling real-time tick data (Part 5)

## 184. Working with historical data and real-time tick data (Part 1)

## 185. Working with historical data and real-time tick data (Part 2)

## 186. Working with historical data and real-time tick data (Part 3)

## 187. Defining a simple Contrarian Strategy

## 188. Placing Orders and Executing Trades

## 189. Trade Monitoring and Reporting

## 190. Trading other Strategies - Coding Challenge

## 191. Implementing an SMA Crossover Strategy (Solution)

## 192. Implementing a Bollinger Bands Strategy (Solution)

## 193. Machine Learning Strategies (1) - Model Fitting

## 194. Machine Learning Strategies (2) - Implementation

## 195. Importing a Trader Module / Class

## 196. Running a Python Trader Script

## 197. **Weekend and Bank Holiday Alert**

## 198. Historical Data, real-time Data and Orders (Recap)

## 199. Troubleshooting: FXCM Server Connection Issues

## 200. Preview: A Trader Class live in action

## 201. Collecting and storing real-time tick data

## 202. Storing and resampling real-time tick data (Part 1)

## 203. A Trader Class

## 204. Storing and resampling real-time tick data (Part 2)

## 205. Storing and resampling real-time tick data (Part 3)

## 206. Working with historical data and real-time tick data (Part 1)

## 207. Working with historical data and real-time tick data (Part 2)

## 208. Working with historical data and real-time tick data (Part 3)

## 209. Defining a Simple Contrarian Trading Strategy

## 210. Placing Orders and Executing Trades

## 211. Trade Monitoring and Reporting

## 212. Trading other Strategies - Coding Challenge

## 213. SMA Crossover and Bollinger Bands (Solution)

## 214. Machine Learning Strategies (1) - Model Fitting

## 215. Machine Learning Strategies (2) - Implementation

## 216. Running a Python Script

## 217. Introduction and Motivation

## 218. Demonstration: AWS EC2 for Algorithmic Trading live in action

## 219. Amazon Web Services (AWS) - Overview and how to create a Free Trial Account

## 220. How to create an EC2 Instance

## 221. How to connect to your EC2 Instance

## 222. Getting the Instance Ready for Algorithmic Trading

## 223. **Weekend and Bank Holiday Alert**

## 224. How to run Python Scripts in a Windows Command Prompt

## 225. How to start Trading sessions with Batch (.bat) Files

## 226. How to schedule Trading sessions with the Task Scheduler

## 227. How to stop Trading Sessions (OANDA)

## 228. How to stop Trading Sessions (FXCM)

## 229. Overview

## 230. Downloads for PART 5

## 231. Introduction and Preparing the Data

## 232. The best time to trade (Part 1)

## 233. The best time to trade (Part 2)

## 234. Spreads during the busy hours

## 235. The Impact of Granularity

## 236. Conclusions

## 237. Introduction

## 238. Strategy 1: SMA

## 239. Strategy 2: Mean Reversion

## 240. Combining both Strategies - Alternative 1

## 241. Taking into account busy Trading Hours

## 242. Strategy Backtesting

## 243. Combining both Strategies - Alternative 2

## 244. Strategy Optimization

## 245. Project Overview

## 246. Installation of Tensorflow & Keras (Part 1)

## 247. Installation of Tensorflow & Keras (Part 2)

## 248. Getting and Preparing the Data

## 249. Adding Labels/Features

## 250. Adding lags

## 251. Splitting into Train and Test Set

## 252. Feature Scaling/Engineering

## 253. Creating and Fitting the DNN Model

## 254. Prediction & Out-Sample Forward Testing

## 255. Saving Model and Parameters

## 256. **Important Notices**

## 257. Implementation (Oanda & FXCM)

## 258. Overview

## 259. Section Downloads

## 260. Intro to the Time Value of Money (TVM) Concept (Theory)

## 261. Calculate Future Values (FV) with Python / Compounding

## 262. Calculate Present Values (FV) with Python / Discounting

## 263. Interest Rates and Returns (Theory)

## 264. Calculate Interest Rates and Returns with Python

## 265. Introduction to Variables

## 266. Excursus: How to add inline comments

## 267. Variables and Memory (Theory)

## 268. More on Variables and Memory

## 269. Variables - Dos, Don´ts and Conventions

## 270. The print() Function

## 271. Coding Exercise 1

## 272. TVM Problems with many Cashflows

## 273. Intro to Python Lists

## 274. Zero-based Indexing and negative Indexing in Python (Theory)

## 275. Indexing Lists

## 276. For Loops - Iterating over Lists

## 277. The range Object - another Iterable

## 278. Calculate FV and PV for many Cashflows

## 279. The Net Present Value - NPV (Theory)

## 280. Calculate an Investment Project´s NPV

## 281. Coding Exercise 2

## 282. Data Types in Action

## 283. The Data Type Hierarchy (Theory)

## 284. Excursus: Dynamic Typing in Python

## 285. Build-in Functions

## 286. Integers

## 287. Floats

## 288. How to round Floats (and Integers) with round()

## 289. More on Lists

## 290. Lists and Element-wise Operations

## 291. Slicing Lists

## 292. Slicing Cheat Sheet

## 293. Changing Elements in Lists

## 294. Sorting and Reversing Lists

## 295. Adding and removing Elements from/to Lists

## 296. Mutable vs. immutable Objects (Part 1)

## 297. Mutable vs. immutable Objects (Part 2)

## 298. Coding Exercise 3

## 299. Tuples

## 300. Dictionaries

## 301. Intro to Strings

## 302. String Replacement

## 303. Booleans

## 304. Operators (Theory)

## 305. Comparison, Logical and Membership Operators in Action

## 306. Coding Exercise 4

## 307. Conditional Statements

## 308. Keywords pass, continue and break

## 309. Calculate a Project´s Payback Period

## 310. Introduction to while loops

## 311. Coding Exercise 5

## 312. Section Downloads

## 313. Defining your first user-defined Function

## 314. What´s the difference between Positional Arguments vs. Keyword Arguments?

## 315. How to work with Default Arguments

## 316. The Default Argument None

## 317. How to unpack Iterables

## 318. Sequences as arguments and *args

## 319. How to return many results

## 320. Scope - easily explained

## 321. Coding Exercise 6

## 322. Downloads for this Section

## 323. Modules, Packages and Libraries - No need to reinvent the Wheel

## 324. Numpy Arrays

## 325. Indexing and Slicing Numpy Arrays

## 326. Vectorized Operations with Numpy Arrays

## 327. Changing Elements in Numpy Arrays & Mutability

## 328. View vs. copy - potential Pitfalls when slicing Numpy Arrays

## 329. Numpy Array Methods and Attributes

## 330. Numpy Universal Functions

## 331. Boolean Arrays and Conditional Filtering

## 332. Advanced Filtering & Bitwise Operators

## 333. Determining a Project´s Payback Period with np.where()

## 334. Creating Numpy Arrays from Scratch

## 335. Coding Exercise 7

## 336. How to work with nested Lists

## 337. 2-dimensional Numpy Arrays

## 338. How to slice 2-dim Numpy Arrays (Part 1)

## 339. How to slice 2-dim Numpy Arrays (Part 2)

## 340. Recap: Changing Elements in a Numpy Array / slice

## 341. How to perform row-wise and column-wise Operations

## 342. Coding Exercise 8

## 343. Intro to Tabular Data / Pandas

## 344. Create your very first Pandas DataFrame (from csv)

## 345. Pandas Display Options and the methods head() & tail()

## 346. First Data Inspection

## 347. Coding Exercise 9

## 348. Selecting Columns

## 349. Selecting one Column with the "dot notation"

## 350. Zero-based Indexing and Negative Indexing

## 351. Selecting Rows with iloc (position-based indexing)

## 352. Slicing Rows and Columns with iloc (position-based indexing)

## 353. Position-based Indexing Cheat Sheets

## 354. Selecting Rows with loc (label-based indexing)

## 355. Slicing Rows and Columns with loc (label-based indexing)

## 356. Label-based Indexing Cheat Sheets

## 357. Summary, Best Practices and Outlook

## 358. Coding Exercise 10

## 359. First Steps with Pandas Series

## 360. Analyzing Numerical Series with unique(), nunique() and value_counts()

## 361. Analyzing non-numerical Series with unique(), nunique(), value_counts()

## 362. The copy() method

## 363. Sorting of Series and Introduction to the inplace - parameter

## 364. First Steps with Pandas Index Objects

## 365. Changing Row Index with set_index() and reset_index()

## 366. Changing Column Labels

## 367. Renaming Index & Column Labels with rename()

## 368. Filtering DataFrames (one Condition)

## 369. Filtering DataFrames by many Conditions (AND)

## 370. Filtering DataFrames by many Conditions (OR)

## 371. Advanced Filtering with between(), isin() and ~

## 372. Intro to NA Values / missing Values

## 373. Handling NA Values / missing Values

## 374. Exporting DataFrames to csv

## 375. Summary Statistics and Accumulations

## 376. Visualization with Matplotlib (Intro)

## 377. Customization of Plots

## 378. Histogramms (Part 1)

## 379. Histogramms (Part 2)

## 380. Scatterplots

## 381. First Steps with Seaborn

## 382. Categorical Seaborn Plots

## 383. Seaborn Regression Plots

## 384. Seaborn Heatmaps

## 385. Removing Columns

## 386. Introduction to GroupBy Operations

## 387. Understanding the GroupBy Object

## 388. Splitting with many Keys

## 389. split-apply-combine

## 390. Get your special BONUS here!


